#!/usr/bin/env python3

import os
import pickle
import requests
import utils
import cli
import time
import random
from argparse import ArgumentParser
from termcolor import cprint

class App:
    def __init__(self):

        self.query_url = "https://en.oxforddictionaries.com/definition/{}"
        self.myDict = {}
        if not os.path.exists("dict"):
            self.saveDict()
        self.loadDict()

    def internet_on(self):
        ''' Check internet connection. '''
        try:
            r = requests.get("https://www.google.com/", timeout = 1)
            return True
        except requests.exceptions.RequestException as e: 
            print("Internet is not connected. Please check your internet connection.")
            return False

    def printIntro(self):
        utils.renderText(" Vocab ")
        cprint("A lightweight dictionay and vocabulary cli.", 'grey', 'on_white', end = '\n')
    
    def printHeader(self):
        print(" Your saved words: ", end = '')
        cprint(len(self.myDict), 'yellow', end = "\n\n")
    
    def printCount(self):
        knownCnt = sum([1 for word in self.myDict if self.myDict[word]["know"]])
        cprint(" Know       {0: >10} ".format(knownCnt), "white", "on_green")
        cprint(" Don't know {0: >10} ".format(len(self.myDict) - knownCnt), "white","on_red", end = "\n\n")

    def printSummary(self):
        self.printHeader()
        self.printCount()
    
    def printNotes(self, notes):
        cprint(" My Notes ", "red", "on_white")
        for i in range(len(notes)):
            cprint("{0: >5} ".format(i + 1), "magenta", end = '')
            print(notes[i])
        
    def launch(self, mode):
        if not self.internet_on():
            return

        self.sess = requests.Session()
        self.printIntro()

        if mode == 'query':
            self.runQueryMode()
        elif mode == 'edit':
            self.runEditMode()
        elif mode == 'interactive':
            self.runInteractiveMode()
        self.saveDict()
        self.end()
    
    def runInteractiveMode(self):
        self.printSummary()
        wordList = list(self.myDict.keys())
        if not wordList:
            print("No words in your dictionary!")
            return
        while True:
            idx = random.randint(0, len(wordList) - 1)
            cprint(" >> ", "cyan", end = '')
            print(wordList[idx])
            know = input("Know this word? [y]['q' to quit]: ")
            know = know.lower()
            if know == 'q':
                break
            self.myDict[wordList[idx]]["know"] = True if know == 'y' else False
            cli.clearConsole(5)
            self.printCount()

    def runEditMode(self):
        ''' Edit saved words. '''
        self.printHeader()
        word = input("Edit word ['q' to quit]: ")
        word = word.lower()
        if word == 'q':
            return
        if word not in self.myDict:
            save = input("Add word to dictionary? [y]: ")
            if save.lower() == 'y':
                query = self.query_url.format(word)
                r =  utils.parseQuery(self.sess.get(query).text)
                self.myDict[word] = {"def" : r, "notes" : [], "know" : False}
                self.saveDict()
            else:
                return
        print("\n", end = '')
        utils.showQuery(self.myDict[word]["def"])
        print("\n", end = '')
        self.printNotes(self.myDict[word]["notes"])
        print("\n", end = '')
        self.addNotes(word)

    def runQueryMode(self):
        ''' Query mode of app. '''
        print('\n', end = '')
        while True:
            cli.clearLine()
            word = input("Enter Word to Query ['q' to quit]: ")
            word = word.lower()
            if word == 'q':
                break
            result, lineCnt = self.query(word)
            self.saveWord(word, result)
            if not result:
                cli.clearConsole(lineCnt + 1)
            else:
                cli.clearConsole(lineCnt + 2)

    def query(self, word):
        ''' Query word from online dictionary or cached. '''
        if word in self.myDict:
            # Retrieve from own dictionary
            r = self.myDict[word]["def"]
        else:
            # New query
            query = self.query_url.format(word)
            r =  utils.parseQuery(self.sess.get(query).text)
        return utils.showQuery(r)

    def saveDict(self):
        with open("dict", "wb") as file:
            pickle.dump(self.myDict, file)
    
    def loadDict(self):
        with open("dict", "rb") as file:
            self.myDict = pickle.load(file)

    def addNotes(self, word):
        while True:
            s = input("Enter notes (or enter index to delete) ['q' to quit]: ")
            cli.moveCursorUp(1)
            cli.clearLine()
            if s.lower() == 'q':
                return
            if s.isdigit():
                if int(s) > 0 and int(s) <= len(self.myDict[word]["notes"]):
                    cli.clearConsole(2 + len(self.myDict[word]["notes"]))
                    self.myDict[word]["notes"].pop(int(s) - 1)
                    self.printNotes(self.myDict[word]["notes"])
                    print("\n", end = '')
            else:
                self.myDict[word]["notes"].append(s)
                cli.clearConsole(1 + len(self.myDict[word]["notes"]))
                self.printNotes(self.myDict[word]["notes"])
                print("\n", end = '')
            self.saveDict()
        
    def saveWord(self, word, result):
        ''' Save word to word list. '''
        if not result:
            time.sleep(1)
        else:
            save = input("Save word? [y] : ")
            if save.lower() == 'y':
                self.myDict[word] = {"def" : result, "notes" : [], "know" : False}
            self.saveDict()

    def end(self):
        self.sess.close()
    
    def guard(self):
        r = input("Are you sure you want to reset the dictionary? (All saved words will be lost) [y]: ")
        if r.lower() == 'y':
            self.reset()
    
    def reset(self):
        ''' Reset cache dictionary. '''
        self.myDict = {}
        with open("dict", "wb") as file:
            pickle.dump(self.myDict, file)

if __name__ == "__main__":

    parser = ArgumentParser()
    parser.add_argument("-m", "--mode", default = "query", choices = ["edit", "query", "interactive"], help = "Select app mode.")
    parser.add_argument("-r", "--reset", action = "store_true", help = "Reset dictionary.")
    args = parser.parse_args()

    app = App()
    if args.reset:
        app.guard()
    else:
        app.launch(mode = args.mode)